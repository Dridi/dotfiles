#!/bin/sh

set -e

SUBDIRECTORY_OK=yes
OPTIONS_KEEPDASHDASH=yes
OPTIONS_STUCKLONG=yes
OPTIONS_SPEC="\
git tree [-adf] [-L level]
--
 Listing options
a,all!             all files are printed
d,directory-only!  list directories only
f,full-path!       print the full path prefix for each file
L,level=           descend only <level> directories deep
"
. git-sh-setup
require_work_tree_exists

match_type='blob|tree'
match_name='^[^.]'
print_name=base
max_level=

while test $# != 0
do
	case "$1" in
	--all)
		match_name=.
		;;
	--directory-only)
		match_type=tree
		;;
	--full-path)
		print_name=full
		;;
	--level=*)
		max_level=${1#--level=}
		;;
	--)
		shift
		break
		;;
	esac
	shift
done

[ $# -gt 0 ] && usage

within_max_level() {
	test -n "$max_level" || return 0

	current_level=$(printf '%s' "$1" | tr '/' '\n' | wc -l)
	test "$current_level" -lt "$max_level"
}

tree_print() {
	if [ "$print_name" = full ]
	then
		file_name="$1/$3"
	else
		file_name=$3
	fi
	printf '\n'
	printf '%s' "$2"
	printf ' %s' "$file_name"
	if [ "$4" = tree ]
	then
		tree "$1/$3" "$5" "${2%???}|   |--"
	fi
}

tree_walk() {
	read -r mode type hash name || return 0

	while read -r mode next_type next_hash next_name
	do
		tree_print "$1" "$2" "$name" "$type" "$hash"
		type=$next_type
		hash=$next_hash
		name=$next_name
	done

	tree_print "$1" "${2%|--}'--" "$name" "$type" "$hash"
}

tree() {
	within_max_level "$1" || return 0
	git ls-tree "$2" |
	awk '$2 ~ match_type && $4 ~ match_name' \
		match_type="$match_type" \
		match_name="$match_name" |
	tree_walk "$1" "$3"
}

{
	printf .
	tree . HEAD '|--'
	printf '\n'
} |
git_pager
