#!/bin/sh

set -e

SUBDIRECTORY_OK=yes
OPTIONS_KEEPDASHDASH=yes
OPTIONS_STUCKLONG=yes
OPTIONS_SPEC="\
git tree [-adf] [-L level] [--charset charset] [--noreport] [<tree-ish>]
--
 Listing options
a,all!             all files are printed
d,directory-only!  list directories only
f,full-path!       print the full path prefix for each file
L,level=           descend only <level> directories deep
charset=           use <charset> for terminal indentation lines
noreport!          turn off file/directory count at end of tree listing
 Graphics options
n!                 turn colorization off always, over-ridden by -C
C!                 turn colorization on always
"
. git-sh-setup
require_work_tree_exists

match_type='blob|tree'
match_name='^[^.]'
print_name=base
max_level=
root_tree=HEAD
charmap=$(locale charmap)
noreport=
colors=

while test $# != 0
do
	case "$1" in
	--all)
		match_name=.
		;;
	-C)
		colors=always
		;;
	--charset=*)
		charmap=${1#--charset=}
		;;
	--directory-only)
		match_type=tree
		;;
	--full-path)
		print_name=full
		;;
	--level=*)
		max_level=${1#--level=}
		;;
	-n)
		test "$colors" = always || colors=no
		;;
	--noreport)
		noreport=yes
		;;
	--)
		shift
		break
		;;
	esac
	shift
done

if [ $# -gt 0 ]
then
	root_tree=$1
	shift
fi

[ $# -gt 0 ] && usage

root_type=$(git cat-file -t "$root_tree")

if [ "$root_type" != tree ] && [ "$root_type" != commit ]
then
	die "$(eval_gettext "fatal: not a tree object: \$root_tree")"
fi

case $charmap in
UTF-8|UTF8|utf-8|utf8)
	line_vbar=│
	line_file=├
	line_last=└
	line_hbar=─
	;;
CP437|IBM437|cp437|ibm437)
	line_vbar="\xb3"
	line_file="\xc3"
	line_last="\xc0"
	line_hbar="\xc4"
	;;
*)
	line_vbar='|'
	line_file='|'
	line_last="'"
	line_hbar=-
	;;
esac

tree_color() {
	git config --get-color color.tree."$1" "$2"
}

color_dir=
color_file=
color_link=
color_exec=
color_line=
color_reset=

if ([ -t 1 ] || [ "$colors" = always ]) && [ "$colors" != no ]
then
	color_dir=$(tree_color directory blue)
	color_file=$(tree_color file white)
	color_link=$(tree_color link yellow)
	color_exec=$(tree_color executable green)
	color_line=$(tree_color line white)
	color_reset=$(git config --get-color '' reset)
fi

within_max_level() {
	test -n "$max_level" || return 0

	current_level=$(printf '%s' "$1" | tr '/' '\n' | wc -l)
	test "$current_level" -lt "$max_level"
}

tree_print_colored() {
	case $1 in
	040000) color=$color_dir ;;
	100644) color=$color_file ;;
	120000) color=$color_link ;;
	100755) color=$color_exec ;;
	line)   color=$color_line ;;
	*)      color= ;;
	esac
	printf '%s%s%s' "$color" "$2" "$color_reset"
}

tree_print() {
	if [ "$print_name" = full ]
	then
		file_name="$1/$6"
	else
		file_name=$6
	fi

	printf '\n%s\n' "$4"

	# GNU tr doesn't support multi-byte characters...
	line_prefix=$(
		printf '%s' "$2" |
		sed "
			s/[|]/$line_vbar/g
			s/[+]/$line_file/g
			s/[']/$line_last/g
			s/[-]/$line_hbar/g
		"
	)
	tree_print_colored line "$line_prefix"
	tree_print_colored "$3" " $file_name"

	if [ "$3" = 120000 ]
	then
		tree_print_colored "$3" " -> $(git cat-file blob "$5")"
	fi

	if [ "$4" = tree ]
	then
		if [ "$2" != "${2%\'--}" ]
		then
			lines="${2%???}    +--"
		else
			lines="${2%???}|   +--"
		fi
		tree "$1/$6" "$5" "$lines"
	fi
}

tree_walk() {
	read -r mode type hash name || return 0

	while read -r next_mode next_type next_hash next_name
	do
		tree_print "$1" "$2" "$mode" "$type" "$hash" "$name"
		mode=$next_mode
		type=$next_type
		hash=$next_hash
		name=$next_name
	done

	tree_print "$1" "${2%???}'--" "$mode" "$type" "$hash" "$name"
}

tree() {
	within_max_level "$1" || return 0
	git ls-tree "$2" |
	awk '$2 ~ match_type && $4 ~ match_name' \
		match_type="$match_type" \
		match_name="$match_name" |
	tree_walk "$1" "$3"
}

[ -n "$noreport" ] ||
awk_print_report='END { print "\n\n" tree " directories, " blob " files" }'

{
	tree_print_colored 040000 .
	tree . "$root_tree" '+--' |
	awk '
		BEGIN { blob=0; tree=0 }
		$1 == "blob" { blob++ }
		$1 == "tree" { tree++ }
		$1 !~ "blob|tree" { print }
		'"$awk_print_report"'
	'
} |
git_pager
